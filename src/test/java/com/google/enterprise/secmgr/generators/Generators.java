// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.enterprise.secmgr.generators;

import com.google.common.base.Function;
import com.google.common.base.Preconditions;
import com.google.common.collect.AbstractIterator;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.enterprise.secmgr.common.Chain;

import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.annotation.Nonnull;
import javax.annotation.ParametersAreNonnullByDefault;

/**
 * A collection of useful static methods for generators.
 */
@ParametersAreNonnullByDefault
public final class Generators {

  // Don't instantiate.
  private Generators() {
    throw new UnsupportedOperationException();
  }

  /**
   * Makes a generator with some given elements.
   *
   * @param elements The elements to be generated; individual elements can be
   *     {@code null}.
   * @return A generator that sources those elements, in order.
   */
  @Nonnull
  public static Generator of(Object... elements) {
    return ArrayGenerator.make(elements);
  }

  /**
   * Makes a generator with some given elements.
   *
   * @param elements The elements to be generated; individual elements can be
   *     {@code null}.
   * @return A generator that sources those elements, in order.
   */
  @Nonnull
  public static Generator of(Iterable<? extends Object> elements) {
    return ListGenerator.make(elements);
  }

  /**
   * Makes a generator that concatenates the output from some given generators.
   *
   * @param generators The generators to concatenate the output from.
   * @return A generator producing the concatenated sequence.
   */
  @Nonnull
  public static Generator concat(Generator... generators) {
    return GeneratorConcatenator.make(generators);
  }

  /**
   * Makes a cross-product generator.
   * <p>
   * A cross-product generator supplies a "cross product" of some given
   * generators.  This means that it generates a sequence of arrays, each
   * element of which comes from the corresponding generator.  All possible
   * combinations of elements are generated, so the length of the sequence
   * generated by this generator is the product of the lengths of all the input
   * sequences.  Each element of the output sequence is an array whose length is
   * the same as the number of given generators.  So if this is a cross product
   * of three generators, the output sequence will consist of arrays of length
   * three.
   *
   * @param generators The generators providing the sequences to multiply.
   * @return A cross-product generator for the given input generators.
   */
  @Nonnull
  public static Generator crossProduct(Generator... generators) {
    return CrossProductGenerator.make(generators);
  }

  /**
   * Makes a joining generator.
   * <p>
   * A joining generator combines the elements of a set of input generators.
   * This works exactly like {@link #crossProduct} except that a {@code null}
   * value in an input stream is dropped from the result.  The elements of the
   * output sequence of this generator are arrays, but unlike the elements from
   * a cross-product generator, these arrays may have fewer elements than the
   * number of input generators.
   * <p>
   * Basically this is useful for building up output sequences by doing cross
   * products, but where the arity of the output element is unimportant.  The
   * output element is just a sequence of input elements that preserves order.
   *
   * @param generators The generators providing the sequences to join.
   * @return A joining generator for the given input generators.
   */
  @Nonnull
  public static Generator join(Generator... generators) {
    return JoiningGenerator.make(generators);
  }

  /**
   * Casts the elements of an {@link Object} iterable to a given type, returning
   * a new iterable of that type.  This conversion assumes that the input
   * elements are already of the right type and just require casting.
   *
   * @param <T> The type of the generator's elements.
   * @param clazz The class corresponding to {@code <T>}.
   * @param generator The generator to convert.
   * @return An iterable of type {@code <T>}.
   */
  @Nonnull
  public static <T> Iterable<T> castElements(Class<T> clazz, Iterable<Object> generator) {
    return Iterables.transform(generator, castingFunction(clazz));
  }

  /**
   * Returns a function that casts an object to a given type.
   *
   * @param <T> The type to cast the object to.
   * @param clazz The class for that type.
   * @return The corresponding casting function.
   */
  @Nonnull
  public static <T> Function<Object, T> castingFunction(final Class<T> clazz) {
    Preconditions.checkNotNull(clazz);
    return new Function<Object, T>() {
      public T apply(Object object) {
        return clazz.cast(object);
      }
    };
  }

  /**
   * Makes an iterable that's the cross product of some given generators.  This
   * is like {@link CrossProductGenerator} except that the output elements are
   * cast to arrays, and the array lengths are checked.
   *
   * @param generators The generators to take the cross product of.
   * @return An iterable whose elements are arrays of the correct length.
   */
  @Nonnull
  public static Iterable<Object[]> crossProductIterable(Generator... generators) {
    final int n = generators.length;
    return Iterables.transform(crossProduct(generators),
        new Function<Object, Object[]>() {
          public Object[] apply(Object object) {
            Object[] objects = Object[].class.cast(object);
            Preconditions.checkArgument(objects.length == n);
            return objects;
          }
        });
  }

  /**
   * Computes the power set of some given elements.  The result is represented
   * as an iterable of sets.  If the input has N elements, the resulting output
   * has 2^N elements.  For this reason, the result is computed incrementally
   * rather than being instantiated as a collection.
   *
   * @param elements The elements to get the power set of.
   * @return The power set as a set of sets.
   */
  @Nonnull
  public static <T> Iterable<Set<T>> powerSetOf(Iterable<T> elements) {
    return Chain.toSets(powerChainOf(elements));
  }

  /**
   * Computes the power set of some given elements.  The result is represented
   * as an iterable of lists.  If the input has N elements, the resulting output
   * has 2^N elements.  For this reason, the result is computed incrementally
   * rather than being instantiated as a collection.
   *
   * @param elements The elements to get the power list of.
   * @return The power list as a list of lists.
   */
  @Nonnull
  public static <T> Iterable<List<T>> powerListOf(Iterable<T> elements) {
    return Chain.toLists(powerChainOf(elements));
  }

  /**
   * Computes the power set of some given elements.  The result is represented
   * as an iterable of chains.  If the input has N elements, the resulting
   * output has 2^N elements.  For this reason, the result is computed
   * incrementally rather than being instantiated as a collection.
   *
   * @param elements The elements to get the power chain of.
   * @return The power chain as a chain of chains.
   */
  @Nonnull
  public static <T> Iterable<Chain<T>> powerChainOf(Iterable<T> elements) {
    Iterable<Chain<T>> result = ImmutableList.of(Chain.<T>empty());
    for (T element : elements) {
      result = Iterables.concat(result, Chain.addToChains(result, element));
    }
    return result;
  }

  /**
   * Makes the permutations of some given elements.  Because the number of
   * permutations grows so fast with the number of elements, the returned value
   * is incrementally generated by an iterator rather than returned as a
   * collection.
   *
   * @param elements The elements to permute.
   * @return The permutations as a iterable of lists.
   */
  @Nonnull
  public static <T> Iterable<List<T>> permutationsOf(Iterable<T> elements) {
    final ImmutableList<T> copy = ImmutableList.copyOf(elements);
    if (copy.size() < 2) {
      return ImmutableList.<List<T>>of(copy);
    }
    return new Iterable<List<T>>() {
      @Override
      public Iterator<List<T>> iterator() {
        return new HeapPermuteIterator<T>(arrayOf(copy));
      }
    };
  }

  private static <T> T[] arrayOf(List<T> elements) {
    @SuppressWarnings("unchecked")
    T[] zero = (T[]) new Object[0];
    return elements.toArray(zero);
  }

  /*
  // This is the code that HeapPermuteIterator is based on:

  // See: A. Levitin, Introduction to The Design & Analysis of Algorithms, Addison Wesley, 2003
  private static <T> void heapPermute(T[] a, int n, ImmutableList.Builder<List<T>> builder) {
    if (n == 1) {
      builder.add(ImmutableList.copyOf(a));
      return;
    }
    for (int i = 0; i < n; i += 1) {
      heapPermute(a, n - 1, builder);
      swap(a, (n % 2 == 0) ? 0 : i, n - 1);
    }
  }
  */

  private static final class HeapPermuteIterator<T> extends AbstractIterator<List<T>> {
    final T[] a;
    int[] stack;
    int n;
    int i;

    HeapPermuteIterator(T[] a) {
      super();
      this.a = a;
      stack = new int[a.length];
      n = a.length;
      i = 0;
    }

    @Override
    protected List<T> computeNext() {
      while (true) {
        if (i < n) {
          if (n == 1) {
            i += 1;
            return ImmutableList.copyOf(a);
          }
          stack[--n] = i;
          i = 0;
          continue;
        }
        if (n == a.length) {
          return endOfData();
        }
        i = stack[n++];
        int i1 = (n % 2 == 0) ? 0 : i;
        int i2 = n - 1;
        T element = a[i1];
        a[i1] = a[i2];
        a[i2] = element;
        i += 1;
      }
    }
  }
}
