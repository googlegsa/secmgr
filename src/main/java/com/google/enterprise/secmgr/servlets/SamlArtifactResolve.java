// Copyright 2008 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.enterprise.secmgr.servlets;

import static com.google.enterprise.secmgr.saml.OpenSamlUtil.getBasicParserPool;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.getCheckMandatoryIssuerHandler;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.getXmlSignatureHandler;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.initializeSecurityPolicy;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.makeArtifactResponse;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.makeStatus;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.makeStatusCode;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.makeStatusMessage;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.makeSuccessfulStatus;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.runDecoder;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.runEncoder;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.runInboundMessageHandlers;

import com.google.common.annotations.VisibleForTesting;
import com.google.enterprise.secmgr.common.Decorator;
import com.google.enterprise.secmgr.common.PostableHttpServlet;
import com.google.enterprise.secmgr.saml.SamlSharedData;
import com.google.inject.Singleton;
import java.io.IOException;
import java.util.logging.Logger;
import javax.annotation.concurrent.Immutable;
import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.joda.time.DateTime;
import org.opensaml.messaging.context.MessageContext;
import org.opensaml.messaging.handler.MessageHandlerException;
import org.opensaml.saml.common.SAMLObject;
import org.opensaml.saml.common.binding.artifact.SAMLArtifactMap;
import org.opensaml.saml.common.binding.artifact.SAMLArtifactMap.SAMLArtifactMapEntry;
import org.opensaml.saml.common.messaging.context.SAMLPeerEntityContext;
import org.opensaml.saml.common.xml.SAMLConstants;
import org.opensaml.saml.saml2.binding.decoding.impl.HTTPSOAP11Decoder;
import org.opensaml.saml.saml2.binding.encoding.impl.HTTPSOAP11Encoder;
import org.opensaml.saml.saml2.core.ArtifactResolve;
import org.opensaml.saml.saml2.core.ArtifactResponse;
import org.opensaml.saml.saml2.core.Status;
import org.opensaml.saml.saml2.core.StatusCode;
import org.opensaml.saml.saml2.metadata.AssertionConsumerService;
import org.opensaml.soap.messaging.context.SOAP11Context;

/**
 * Servlet to handle SAML artifact-resolution requests.  This is one part of the security manager's
 * identity provider, and will handle only those artifacts generated by the identity provider.
 */
@Singleton
@Immutable
public class SamlArtifactResolve extends SamlServlet implements PostableHttpServlet {
  private static final Logger logger = Logger.getLogger(SamlArtifactResolve.class.getName());

  @SuppressWarnings("unused")
  @Inject
  private SamlArtifactResolve() {
    super(SamlSharedData.getProductionInstance(SamlSharedData.Role.IDENTITY_PROVIDER));
  }

  @VisibleForTesting
  public SamlArtifactResolve(SamlSharedData sharedData) {
    super(sharedData);
  }

  @Override
  public void doPost(HttpServletRequest req, HttpServletResponse resp)
      throws IOException {
    Decorator decorator = getLogDecorator(req);
    logger.info(decorator.apply("Enter artifact resolver"));

    // Establish the SAML message context.
    MessageContext<SAMLObject> context = makeSamlMessageContext(req);

    Status status = null;
    SAMLObject responseObject = null;

    initializeSecurityPolicy(context, getCheckMandatoryIssuerHandler(), getXmlSignatureHandler());

    // Decode the request.
    HTTPSOAP11Decoder decoder = new HTTPSOAP11Decoder();
    decoder.setHttpServletRequest(req);
    decoder.setParserPool(getBasicParserPool());
    try {
      runDecoder(decoder, context, decorator);
      initializePeerEntity(
          context,
          AssertionConsumerService.DEFAULT_ELEMENT_NAME,
          SAMLConstants.SAML2_SOAP11_BINDING_URI);
      runInboundMessageHandlers(context);
    } catch (MessageHandlerException e) {
      logger.warning(decorator.apply("Security exception: " + e.getMessage()));
      status = makeFailureStatus("Unable to authenticate request");
    }
    ArtifactResolve artifactResolve = (ArtifactResolve) context.getMessage();

    // Any errors above will have set status, but if no errors, look up the
    // artifact and add any resulting object to response.
    if (status == null) {
      SAMLArtifactMap artifactMap = getArtifactMap();
      String encodedArtifact = artifactResolve.getArtifact().getArtifact();
      if (!artifactMap.contains(encodedArtifact)) {
        logger.warning(responseMessage("Unknown artifact", encodedArtifact, decorator));
        status = makeFailureStatus("Artifact unacceptable");
      } else {
        SAMLArtifactMapEntry entry = artifactMap.get(encodedArtifact);
        SAMLPeerEntityContext peerEntityContext =
            context.getSubcontext(SAMLPeerEntityContext.class, false);
        String statusMessage =
            entry == null ? "Artifact expired" : checkEntry(entry, peerEntityContext.getEntityId());
        if (statusMessage == null) {
          logger.info(responseMessage("Artifact resolved", encodedArtifact, decorator));
          status = makeSuccessfulStatus();
          responseObject = entry.getSamlMessage();
        } else {
          logger.warning(responseMessage(statusMessage, encodedArtifact, decorator));
          status = makeFailureStatus("Artifact unacceptable");
        }
        // Always remove the artifact after use.
        artifactMap.remove(encodedArtifact);
      }
    }

    // Remove incoming SOAP Envelope
    context.removeSubcontext(SOAP11Context.class);
    ArtifactResponse artifactResponse =
        makeArtifactResponse(getLocalEntityId(), new DateTime(), status, artifactResolve.getID(),
            responseObject);

    // Encode response.
    context.setMessage(artifactResponse);
    initResponse(resp);
    HTTPSOAP11Encoder encoder = new HTTPSOAP11Encoder();
    encoder.setHttpServletResponse(resp);
    runEncoder(encoder, context, decorator);

    logger.info(decorator.apply("Exit artifact resolver"));
  }

  private String checkEntry(SAMLArtifactMapEntry entry, String peerEntityId) {
    if (!getLocalEntityId().equals(entry.getIssuerId())) {
      return "Artifact not issued by this entity";
    }
    if (!peerEntityId.equals(entry.getRelyingPartyId())) {
      return "Artifact not intended for requester";
    }
    return null;
  }

  private static Status makeFailureStatus(String message) {
    return makeStatus(
        makeStatusCode(StatusCode.SUCCESS, StatusCode.REQUEST_DENIED), makeStatusMessage(message));
  }

  private static Decorator getLogDecorator(final HttpServletRequest request) {
    return new Decorator() {
      @Override
      public String apply(String message) {
        return message + " (" + request.hashCode() + ")";
      }
    };
  }

  private static String responseMessage(String statusMessage, String encodedArtifact,
      Decorator decorator) {
    return decorator.apply(statusMessage) + ": " + encodedArtifact;
  }
}
