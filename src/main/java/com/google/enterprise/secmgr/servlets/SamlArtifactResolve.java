// Copyright 2008 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.enterprise.secmgr.servlets;

import static com.google.enterprise.secmgr.saml.OpenSamlUtil.getBasicParserPool;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.getMandatoryIssuerRule;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.getXmlSignatureRule;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.initializeSecurityPolicy;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.makeArtifactResponse;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.makeStatus;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.makeStatusCode;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.makeStatusMessage;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.makeSuccessfulStatus;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.runDecoder;
import static com.google.enterprise.secmgr.saml.OpenSamlUtil.runEncoder;

import com.google.common.annotations.VisibleForTesting;
import com.google.enterprise.secmgr.common.Decorator;
import com.google.enterprise.secmgr.common.PostableHttpServlet;
import com.google.enterprise.secmgr.saml.SamlSharedData;
import com.google.inject.Singleton;

import org.joda.time.DateTime;
import org.opensaml.common.SAMLObject;
import org.opensaml.common.binding.SAMLMessageContext;
import org.opensaml.common.binding.artifact.SAMLArtifactMap;
import org.opensaml.common.binding.artifact.SAMLArtifactMap.SAMLArtifactMapEntry;
import org.opensaml.common.xml.SAMLConstants;
import org.opensaml.saml2.binding.decoding.HTTPSOAP11Decoder;
import org.opensaml.saml2.binding.encoding.HTTPSOAP11Encoder;
import org.opensaml.saml2.core.ArtifactResolve;
import org.opensaml.saml2.core.ArtifactResponse;
import org.opensaml.saml2.core.NameID;
import org.opensaml.saml2.core.Status;
import org.opensaml.saml2.core.StatusCode;
import org.opensaml.saml2.metadata.Endpoint;
import org.opensaml.ws.transport.http.HttpServletRequestAdapter;
import org.opensaml.ws.transport.http.HttpServletResponseAdapter;
import org.opensaml.xml.security.SecurityException;

import java.io.IOException;
import java.util.logging.Logger;

import javax.annotation.concurrent.Immutable;
import javax.inject.Inject;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet to handle SAML artifact-resolution requests.  This is one part of the security manager's
 * identity provider, and will handle only those artifacts generated by the identity provider.
 */
@Singleton
@Immutable
public class SamlArtifactResolve extends SamlServlet implements PostableHttpServlet {
  private static final Logger logger = Logger.getLogger(SamlArtifactResolve.class.getName());

  @SuppressWarnings("unused")
  @Inject
  private SamlArtifactResolve() {
    super(SamlSharedData.getProductionInstance(SamlSharedData.Role.IDENTITY_PROVIDER));
  }

  @VisibleForTesting
  public SamlArtifactResolve(SamlSharedData sharedData) {
    super(sharedData);
  }

  @Override
  public void doPost(HttpServletRequest req, HttpServletResponse resp)
      throws IOException {
    Decorator decorator = getLogDecorator(req);
    logger.info(decorator.apply("Enter artifact resolver"));

    // Establish the SAML message context.
    SAMLMessageContext<ArtifactResolve, ArtifactResponse, NameID> context
        = makeSamlMessageContext(req);

    Status status = null;
    SAMLObject responseObject = null;

    initializeSecurityPolicy(context,
        getMandatoryIssuerRule(),
        getXmlSignatureRule());

    // Decode the request.
    context.setInboundMessageTransport(new HttpServletRequestAdapter(req));
    try {
      runDecoder(new HTTPSOAP11Decoder(getBasicParserPool()), context, decorator,
          ArtifactResolve.DEFAULT_ELEMENT_NAME);
    } catch (SecurityException e) {
      logger.warning(decorator.apply("Security exception: " + e.getMessage()));
      status = makeFailureStatus("Unable to authenticate request");
    }
    ArtifactResolve artifactResolve = context.getInboundSAMLMessage();

    // Select entity for response.
    initializePeerEntity(context, Endpoint.DEFAULT_ELEMENT_NAME,
        SAMLConstants.SAML2_SOAP11_BINDING_URI);

    // Any errors above will have set status, but if no errors, look up the
    // artifact and add any resulting object to response.
    if (status == null) {
      SAMLArtifactMap artifactMap = getArtifactMap();
      String encodedArtifact = artifactResolve.getArtifact().getArtifact();
      if (!artifactMap.contains(encodedArtifact)) {
        logger.warning(responseMessage("Unknown artifact", encodedArtifact, decorator));
        status = makeFailureStatus("Artifact unacceptable");
      } else {
        SAMLArtifactMapEntry entry = artifactMap.get(encodedArtifact);
        String statusMessage = checkEntry(entry, context.getInboundMessageIssuer());
        if (statusMessage == null) {
          logger.info(responseMessage("Artifact resolved", encodedArtifact, decorator));
          status = makeSuccessfulStatus();
          responseObject = entry.getSamlMessage();
        } else {
          logger.warning(responseMessage(statusMessage, encodedArtifact, decorator));
          status = makeFailureStatus("Artifact unacceptable");
        }
        // Always remove the artifact after use.
        artifactMap.remove(encodedArtifact);
      }
    }

    ArtifactResponse artifactResponse =
        makeArtifactResponse(getLocalEntityId(), new DateTime(), status, artifactResolve.getID(),
            responseObject);

    // Encode response.
    context.setOutboundSAMLMessage(artifactResponse);
    initResponse(resp);
    context.setOutboundMessageTransport(new HttpServletResponseAdapter(resp, true));
    runEncoder(new HTTPSOAP11Encoder(), context, decorator);

    logger.info(decorator.apply("Exit artifact resolver"));
  }

  private String checkEntry(SAMLArtifactMapEntry entry, String peerEntityId) {
    if (entry.isExpired()) {
      return "Artifact expired";
    }
    if (!getLocalEntityId().equals(entry.getIssuerId())) {
      return "Artifact not issued by this entity";
    }
    if (!peerEntityId.equals(entry.getRelyingPartyId())) {
      return "Artifact not intended for requester";
    }
    return null;
  }

  private static Status makeFailureStatus(String message) {
    return makeStatus(
        makeStatusCode(StatusCode.SUCCESS_URI, StatusCode.REQUEST_DENIED_URI),
        makeStatusMessage(message));
  }

  private static Decorator getLogDecorator(final HttpServletRequest request) {
    return new Decorator() {
      @Override
      public String apply(String message) {
        return message + " (" + request.hashCode() + ")";
      }
    };
  }

  private static String responseMessage(String statusMessage, String encodedArtifact,
      Decorator decorator) {
    return decorator.apply(statusMessage) + ": " + encodedArtifact;
  }
}
